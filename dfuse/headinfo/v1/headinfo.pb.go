// Code generated by protoc-gen-go. DO NOT EDIT.
// source: dfuse/headinfo/v1/headinfo.proto

package pbheadinfo

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type HeadInfoRequest_Source int32

const (
	HeadInfoRequest_STREAM  HeadInfoRequest_Source = 0
	HeadInfoRequest_NETWORK HeadInfoRequest_Source = 1
	HeadInfoRequest_KVDB    HeadInfoRequest_Source = 2
)

var HeadInfoRequest_Source_name = map[int32]string{
	0: "STREAM",
	1: "NETWORK",
	2: "KVDB",
}

var HeadInfoRequest_Source_value = map[string]int32{
	"STREAM":  0,
	"NETWORK": 1,
	"KVDB":    2,
}

func (x HeadInfoRequest_Source) String() string {
	return proto.EnumName(HeadInfoRequest_Source_name, int32(x))
}

func (HeadInfoRequest_Source) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_62a316d938b72ee6, []int{0, 0}
}

type HeadInfoRequest struct {
	Source               HeadInfoRequest_Source `protobuf:"varint,1,opt,name=source,proto3,enum=dfuse.headinfo.v1.HeadInfoRequest_Source" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *HeadInfoRequest) Reset()         { *m = HeadInfoRequest{} }
func (m *HeadInfoRequest) String() string { return proto.CompactTextString(m) }
func (*HeadInfoRequest) ProtoMessage()    {}
func (*HeadInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_62a316d938b72ee6, []int{0}
}

func (m *HeadInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HeadInfoRequest.Unmarshal(m, b)
}
func (m *HeadInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HeadInfoRequest.Marshal(b, m, deterministic)
}
func (m *HeadInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeadInfoRequest.Merge(m, src)
}
func (m *HeadInfoRequest) XXX_Size() int {
	return xxx_messageInfo_HeadInfoRequest.Size(m)
}
func (m *HeadInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HeadInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HeadInfoRequest proto.InternalMessageInfo

func (m *HeadInfoRequest) GetSource() HeadInfoRequest_Source {
	if m != nil {
		return m.Source
	}
	return HeadInfoRequest_STREAM
}

type HeadInfoResponse struct {
	LibNum               uint64               `protobuf:"varint,1,opt,name=libNum,proto3" json:"libNum,omitempty"`
	LibID                string               `protobuf:"bytes,2,opt,name=libID,proto3" json:"libID,omitempty"`
	HeadNum              uint64               `protobuf:"varint,10,opt,name=headNum,proto3" json:"headNum,omitempty"`
	HeadID               string               `protobuf:"bytes,11,opt,name=headID,proto3" json:"headID,omitempty"`
	HeadTime             *timestamp.Timestamp `protobuf:"bytes,12,opt,name=headTime,proto3" json:"headTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *HeadInfoResponse) Reset()         { *m = HeadInfoResponse{} }
func (m *HeadInfoResponse) String() string { return proto.CompactTextString(m) }
func (*HeadInfoResponse) ProtoMessage()    {}
func (*HeadInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_62a316d938b72ee6, []int{1}
}

func (m *HeadInfoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HeadInfoResponse.Unmarshal(m, b)
}
func (m *HeadInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HeadInfoResponse.Marshal(b, m, deterministic)
}
func (m *HeadInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeadInfoResponse.Merge(m, src)
}
func (m *HeadInfoResponse) XXX_Size() int {
	return xxx_messageInfo_HeadInfoResponse.Size(m)
}
func (m *HeadInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeadInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeadInfoResponse proto.InternalMessageInfo

func (m *HeadInfoResponse) GetLibNum() uint64 {
	if m != nil {
		return m.LibNum
	}
	return 0
}

func (m *HeadInfoResponse) GetLibID() string {
	if m != nil {
		return m.LibID
	}
	return ""
}

func (m *HeadInfoResponse) GetHeadNum() uint64 {
	if m != nil {
		return m.HeadNum
	}
	return 0
}

func (m *HeadInfoResponse) GetHeadID() string {
	if m != nil {
		return m.HeadID
	}
	return ""
}

func (m *HeadInfoResponse) GetHeadTime() *timestamp.Timestamp {
	if m != nil {
		return m.HeadTime
	}
	return nil
}

func init() {
	proto.RegisterEnum("dfuse.headinfo.v1.HeadInfoRequest_Source", HeadInfoRequest_Source_name, HeadInfoRequest_Source_value)
	proto.RegisterType((*HeadInfoRequest)(nil), "dfuse.headinfo.v1.HeadInfoRequest")
	proto.RegisterType((*HeadInfoResponse)(nil), "dfuse.headinfo.v1.HeadInfoResponse")
}

func init() { proto.RegisterFile("dfuse/headinfo/v1/headinfo.proto", fileDescriptor_62a316d938b72ee6) }

var fileDescriptor_62a316d938b72ee6 = []byte{
	// 371 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x92, 0xc1, 0x8b, 0xda, 0x40,
	0x14, 0xc6, 0x3b, 0x36, 0x8d, 0xe9, 0x4b, 0x6b, 0xe3, 0x20, 0x25, 0x78, 0x69, 0x48, 0x2f, 0x96,
	0xd2, 0x49, 0x4d, 0x69, 0x7b, 0xe8, 0x49, 0x51, 0x5a, 0x95, 0xba, 0x10, 0x83, 0x0b, 0xbb, 0xa7,
	0x8c, 0x4e, 0xe2, 0x80, 0xc9, 0x64, 0x4d, 0xe2, 0x7d, 0xff, 0xa9, 0xfd, 0xfb, 0x96, 0x4c, 0x4c,
	0x16, 0x56, 0xd8, 0xbd, 0xec, 0xed, 0x7d, 0x8f, 0xef, 0xfb, 0xe6, 0xf1, 0x63, 0xc0, 0xda, 0x86,
	0x45, 0xc6, 0x9c, 0x1d, 0x0b, 0xb6, 0x3c, 0x09, 0x85, 0x73, 0x1c, 0x36, 0x33, 0x49, 0x0f, 0x22,
	0x17, 0xb8, 0x2b, 0x1d, 0xa4, 0xd9, 0x1e, 0x87, 0xfd, 0x4f, 0x91, 0x10, 0xd1, 0x9e, 0x39, 0xd2,
	0x40, 0x8b, 0xd0, 0xc9, 0x79, 0xcc, 0xb2, 0x3c, 0x88, 0xd3, 0x2a, 0x63, 0xdf, 0x22, 0xf8, 0xf0,
	0x8f, 0x05, 0xdb, 0x59, 0x12, 0x0a, 0x8f, 0xdd, 0x14, 0x2c, 0xcb, 0xf1, 0x08, 0xd4, 0x4c, 0x14,
	0x87, 0x0d, 0x33, 0x91, 0x85, 0x06, 0x1d, 0xf7, 0x0b, 0x39, 0x2b, 0x26, 0x8f, 0x32, 0x64, 0x25,
	0x03, 0xde, 0x29, 0x68, 0x7f, 0x05, 0xb5, 0xda, 0x60, 0x00, 0x75, 0xe5, 0x7b, 0xd3, 0xd1, 0x7f,
	0xe3, 0x15, 0xd6, 0xa1, 0xbd, 0x9c, 0xfa, 0x97, 0x17, 0xde, 0xc2, 0x40, 0x58, 0x03, 0x65, 0xb1,
	0x9e, 0x8c, 0x8d, 0x96, 0x7d, 0x87, 0xc0, 0x78, 0xe8, 0xcb, 0x52, 0x91, 0x64, 0x0c, 0x7f, 0x04,
	0x75, 0xcf, 0xe9, 0xb2, 0x88, 0xe5, 0x11, 0x8a, 0x77, 0x52, 0xb8, 0x07, 0x6f, 0xf6, 0x9c, 0xce,
	0x26, 0x66, 0xcb, 0x42, 0x83, 0xb7, 0x5e, 0x25, 0xb0, 0x09, 0xed, 0xf2, 0xba, 0xd2, 0x0e, 0xd2,
	0x5e, 0xcb, 0xb2, 0xa7, 0x1c, 0x67, 0x13, 0x53, 0x97, 0x81, 0x93, 0xc2, 0xbf, 0x40, 0x2b, 0x27,
	0x9f, 0xc7, 0xcc, 0x7c, 0x67, 0xa1, 0x81, 0xee, 0xf6, 0x49, 0x05, 0x8b, 0xd4, 0xb0, 0x88, 0x5f,
	0xc3, 0xf2, 0x1a, 0xef, 0x5c, 0xd1, 0x5e, 0x1b, 0x30, 0x57, 0xb4, 0xf7, 0x46, 0xcf, 0xa5, 0xa0,
	0xd5, 0x77, 0xe3, 0x35, 0xe8, 0x7f, 0x59, 0xde, 0x48, 0xfb, 0x79, 0x66, 0xfd, 0xcf, 0x4f, 0x7a,
	0x2a, 0x0e, 0x6e, 0x0a, 0xdd, 0x55, 0x7e, 0x60, 0x41, 0xcc, 0x93, 0xa8, 0x69, 0xbf, 0x86, 0x4e,
	0xb5, 0x7c, 0xf1, 0xf7, 0xbe, 0xa3, 0xf1, 0xef, 0xab, 0x9f, 0x11, 0xcf, 0x77, 0x05, 0x25, 0x1b,
	0x11, 0x3b, 0x32, 0xf2, 0x8d, 0x0b, 0x27, 0xa5, 0x91, 0x70, 0xce, 0xfe, 0xe0, 0x9f, 0x94, 0xd6,
	0x8a, 0xaa, 0x12, 0xdc, 0x8f, 0xfb, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb5, 0x3d, 0x60, 0x3a, 0xaa,
	0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// HeadInfoClient is the client API for HeadInfo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type HeadInfoClient interface {
	GetHeadInfo(ctx context.Context, in *HeadInfoRequest, opts ...grpc.CallOption) (*HeadInfoResponse, error)
}

type headInfoClient struct {
	cc *grpc.ClientConn
}

func NewHeadInfoClient(cc *grpc.ClientConn) HeadInfoClient {
	return &headInfoClient{cc}
}

func (c *headInfoClient) GetHeadInfo(ctx context.Context, in *HeadInfoRequest, opts ...grpc.CallOption) (*HeadInfoResponse, error) {
	out := new(HeadInfoResponse)
	err := c.cc.Invoke(ctx, "/dfuse.headinfo.v1.HeadInfo/GetHeadInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HeadInfoServer is the server API for HeadInfo service.
type HeadInfoServer interface {
	GetHeadInfo(context.Context, *HeadInfoRequest) (*HeadInfoResponse, error)
}

// UnimplementedHeadInfoServer can be embedded to have forward compatible implementations.
type UnimplementedHeadInfoServer struct {
}

func (*UnimplementedHeadInfoServer) GetHeadInfo(ctx context.Context, req *HeadInfoRequest) (*HeadInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHeadInfo not implemented")
}

func RegisterHeadInfoServer(s *grpc.Server, srv HeadInfoServer) {
	s.RegisterService(&_HeadInfo_serviceDesc, srv)
}

func _HeadInfo_GetHeadInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeadInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HeadInfoServer).GetHeadInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfuse.headinfo.v1.HeadInfo/GetHeadInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HeadInfoServer).GetHeadInfo(ctx, req.(*HeadInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _HeadInfo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dfuse.headinfo.v1.HeadInfo",
	HandlerType: (*HeadInfoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHeadInfo",
			Handler:    _HeadInfo_GetHeadInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dfuse/headinfo/v1/headinfo.proto",
}

// StreamingHeadInfoClient is the client API for StreamingHeadInfo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StreamingHeadInfoClient interface {
	StreamHeadInfo(ctx context.Context, in *HeadInfoRequest, opts ...grpc.CallOption) (StreamingHeadInfo_StreamHeadInfoClient, error)
}

type streamingHeadInfoClient struct {
	cc *grpc.ClientConn
}

func NewStreamingHeadInfoClient(cc *grpc.ClientConn) StreamingHeadInfoClient {
	return &streamingHeadInfoClient{cc}
}

func (c *streamingHeadInfoClient) StreamHeadInfo(ctx context.Context, in *HeadInfoRequest, opts ...grpc.CallOption) (StreamingHeadInfo_StreamHeadInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_StreamingHeadInfo_serviceDesc.Streams[0], "/dfuse.headinfo.v1.StreamingHeadInfo/StreamHeadInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamingHeadInfoStreamHeadInfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamingHeadInfo_StreamHeadInfoClient interface {
	Recv() (*HeadInfoResponse, error)
	grpc.ClientStream
}

type streamingHeadInfoStreamHeadInfoClient struct {
	grpc.ClientStream
}

func (x *streamingHeadInfoStreamHeadInfoClient) Recv() (*HeadInfoResponse, error) {
	m := new(HeadInfoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StreamingHeadInfoServer is the server API for StreamingHeadInfo service.
type StreamingHeadInfoServer interface {
	StreamHeadInfo(*HeadInfoRequest, StreamingHeadInfo_StreamHeadInfoServer) error
}

// UnimplementedStreamingHeadInfoServer can be embedded to have forward compatible implementations.
type UnimplementedStreamingHeadInfoServer struct {
}

func (*UnimplementedStreamingHeadInfoServer) StreamHeadInfo(req *HeadInfoRequest, srv StreamingHeadInfo_StreamHeadInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamHeadInfo not implemented")
}

func RegisterStreamingHeadInfoServer(s *grpc.Server, srv StreamingHeadInfoServer) {
	s.RegisterService(&_StreamingHeadInfo_serviceDesc, srv)
}

func _StreamingHeadInfo_StreamHeadInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HeadInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamingHeadInfoServer).StreamHeadInfo(m, &streamingHeadInfoStreamHeadInfoServer{stream})
}

type StreamingHeadInfo_StreamHeadInfoServer interface {
	Send(*HeadInfoResponse) error
	grpc.ServerStream
}

type streamingHeadInfoStreamHeadInfoServer struct {
	grpc.ServerStream
}

func (x *streamingHeadInfoStreamHeadInfoServer) Send(m *HeadInfoResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _StreamingHeadInfo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dfuse.headinfo.v1.StreamingHeadInfo",
	HandlerType: (*StreamingHeadInfoServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamHeadInfo",
			Handler:       _StreamingHeadInfo_StreamHeadInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dfuse/headinfo/v1/headinfo.proto",
}
