// Copyright 2019 dfuse Platform Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: dfuse/search/v1/search.proto

package v1

import (
	context "context"
	fmt "fmt"
	deos "github.com/dfuse-io/pbgo/dfuse/codecs/deos"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type RouterRequest_Mode int32

const (
	RouterRequest_STREAMING RouterRequest_Mode = 0
	RouterRequest_PAGINATED RouterRequest_Mode = 1
)

var RouterRequest_Mode_name = map[int32]string{
	0: "STREAMING",
	1: "PAGINATED",
}

var RouterRequest_Mode_value = map[string]int32{
	"STREAMING": 0,
	"PAGINATED": 1,
}

func (x RouterRequest_Mode) String() string {
	return proto.EnumName(RouterRequest_Mode_name, int32(x))
}

func (RouterRequest_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{3, 0}
}

type ForkResolveRequest struct {
	Query                string      `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	ForkedBlockRefs      []*BlockRef `protobuf:"bytes,2,rep,name=forkedBlockRefs,proto3" json:"forkedBlockRefs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ForkResolveRequest) Reset()         { *m = ForkResolveRequest{} }
func (m *ForkResolveRequest) String() string { return proto.CompactTextString(m) }
func (*ForkResolveRequest) ProtoMessage()    {}
func (*ForkResolveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{0}
}

func (m *ForkResolveRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ForkResolveRequest.Unmarshal(m, b)
}
func (m *ForkResolveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ForkResolveRequest.Marshal(b, m, deterministic)
}
func (m *ForkResolveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForkResolveRequest.Merge(m, src)
}
func (m *ForkResolveRequest) XXX_Size() int {
	return xxx_messageInfo_ForkResolveRequest.Size(m)
}
func (m *ForkResolveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ForkResolveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ForkResolveRequest proto.InternalMessageInfo

func (m *ForkResolveRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *ForkResolveRequest) GetForkedBlockRefs() []*BlockRef {
	if m != nil {
		return m.ForkedBlockRefs
	}
	return nil
}

type BlockRef struct {
	BlockNum             uint64   `protobuf:"varint,1,opt,name=blockNum,proto3" json:"blockNum,omitempty"`
	BlockID              string   `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockRef) Reset()         { *m = BlockRef{} }
func (m *BlockRef) String() string { return proto.CompactTextString(m) }
func (*BlockRef) ProtoMessage()    {}
func (*BlockRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{1}
}

func (m *BlockRef) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BlockRef.Unmarshal(m, b)
}
func (m *BlockRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BlockRef.Marshal(b, m, deterministic)
}
func (m *BlockRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRef.Merge(m, src)
}
func (m *BlockRef) XXX_Size() int {
	return xxx_messageInfo_BlockRef.Size(m)
}
func (m *BlockRef) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRef.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRef proto.InternalMessageInfo

func (m *BlockRef) GetBlockNum() uint64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *BlockRef) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

type BackendRequest struct {
	Query        string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	LowBlockNum  uint64 `protobuf:"varint,2,opt,name=lowBlockNum,proto3" json:"lowBlockNum,omitempty"`
	HighBlockNum uint64 `protobuf:"varint,3,opt,name=highBlockNum,proto3" json:"highBlockNum,omitempty"`
	Descending   bool   `protobuf:"varint,4,opt,name=descending,proto3" json:"descending,omitempty"`
	// More specific to the live / reversible backend
	WithReversible       bool     `protobuf:"varint,5,opt,name=withReversible,proto3" json:"withReversible,omitempty"`
	LiveMarkerInterval   uint64   `protobuf:"varint,6,opt,name=liveMarkerInterval,proto3" json:"liveMarkerInterval,omitempty"`
	StopAtVirtualHead    bool     `protobuf:"varint,7,opt,name=stopAtVirtualHead,proto3" json:"stopAtVirtualHead,omitempty"`
	NavigateFromBlockID  string   `protobuf:"bytes,8,opt,name=navigateFromBlockID,proto3" json:"navigateFromBlockID,omitempty"`
	NavigateFromBlockNum uint64   `protobuf:"varint,9,opt,name=navigateFromBlockNum,proto3" json:"navigateFromBlockNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackendRequest) Reset()         { *m = BackendRequest{} }
func (m *BackendRequest) String() string { return proto.CompactTextString(m) }
func (*BackendRequest) ProtoMessage()    {}
func (*BackendRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{2}
}

func (m *BackendRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BackendRequest.Unmarshal(m, b)
}
func (m *BackendRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BackendRequest.Marshal(b, m, deterministic)
}
func (m *BackendRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackendRequest.Merge(m, src)
}
func (m *BackendRequest) XXX_Size() int {
	return xxx_messageInfo_BackendRequest.Size(m)
}
func (m *BackendRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BackendRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BackendRequest proto.InternalMessageInfo

func (m *BackendRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *BackendRequest) GetLowBlockNum() uint64 {
	if m != nil {
		return m.LowBlockNum
	}
	return 0
}

func (m *BackendRequest) GetHighBlockNum() uint64 {
	if m != nil {
		return m.HighBlockNum
	}
	return 0
}

func (m *BackendRequest) GetDescending() bool {
	if m != nil {
		return m.Descending
	}
	return false
}

func (m *BackendRequest) GetWithReversible() bool {
	if m != nil {
		return m.WithReversible
	}
	return false
}

func (m *BackendRequest) GetLiveMarkerInterval() uint64 {
	if m != nil {
		return m.LiveMarkerInterval
	}
	return 0
}

func (m *BackendRequest) GetStopAtVirtualHead() bool {
	if m != nil {
		return m.StopAtVirtualHead
	}
	return false
}

func (m *BackendRequest) GetNavigateFromBlockID() string {
	if m != nil {
		return m.NavigateFromBlockID
	}
	return ""
}

func (m *BackendRequest) GetNavigateFromBlockNum() uint64 {
	if m != nil {
		return m.NavigateFromBlockNum
	}
	return 0
}

type RouterRequest struct {
	Query              string             `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	LowBlockNum        int64              `protobuf:"varint,2,opt,name=lowBlockNum,proto3" json:"lowBlockNum,omitempty"`
	HighBlockNum       int64              `protobuf:"varint,3,opt,name=highBlockNum,proto3" json:"highBlockNum,omitempty"`
	LowBlockUnbounded  bool               `protobuf:"varint,13,opt,name=lowBlockUnbounded,proto3" json:"lowBlockUnbounded,omitempty"`
	HighBlockUnbounded bool               `protobuf:"varint,14,opt,name=highBlockUnbounded,proto3" json:"highBlockUnbounded,omitempty"`
	Descending         bool               `protobuf:"varint,4,opt,name=descending,proto3" json:"descending,omitempty"`
	Cursor             string             `protobuf:"bytes,5,opt,name=cursor,proto3" json:"cursor,omitempty"`
	Limit              int64              `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	WithReversible     bool               `protobuf:"varint,7,opt,name=withReversible,proto3" json:"withReversible,omitempty"`
	Mode               RouterRequest_Mode `protobuf:"varint,8,opt,name=mode,proto3,enum=dfuse.search.v1.RouterRequest_Mode" json:"mode,omitempty"`
	// Legacy boundaries, overrides `lowBlockNum` and `highBlockNum`.
	UseLegacyBoundaries  bool     `protobuf:"varint,9,opt,name=useLegacyBoundaries,proto3" json:"useLegacyBoundaries,omitempty"`
	StartBlock           uint64   `protobuf:"varint,10,opt,name=startBlock,proto3" json:"startBlock,omitempty"`
	BlockCount           uint64   `protobuf:"varint,11,opt,name=blockCount,proto3" json:"blockCount,omitempty"`
	LiveMarkerInterval   uint64   `protobuf:"varint,12,opt,name=liveMarkerInterval,proto3" json:"liveMarkerInterval,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouterRequest) Reset()         { *m = RouterRequest{} }
func (m *RouterRequest) String() string { return proto.CompactTextString(m) }
func (*RouterRequest) ProtoMessage()    {}
func (*RouterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{3}
}

func (m *RouterRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RouterRequest.Unmarshal(m, b)
}
func (m *RouterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RouterRequest.Marshal(b, m, deterministic)
}
func (m *RouterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouterRequest.Merge(m, src)
}
func (m *RouterRequest) XXX_Size() int {
	return xxx_messageInfo_RouterRequest.Size(m)
}
func (m *RouterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouterRequest proto.InternalMessageInfo

func (m *RouterRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *RouterRequest) GetLowBlockNum() int64 {
	if m != nil {
		return m.LowBlockNum
	}
	return 0
}

func (m *RouterRequest) GetHighBlockNum() int64 {
	if m != nil {
		return m.HighBlockNum
	}
	return 0
}

func (m *RouterRequest) GetLowBlockUnbounded() bool {
	if m != nil {
		return m.LowBlockUnbounded
	}
	return false
}

func (m *RouterRequest) GetHighBlockUnbounded() bool {
	if m != nil {
		return m.HighBlockUnbounded
	}
	return false
}

func (m *RouterRequest) GetDescending() bool {
	if m != nil {
		return m.Descending
	}
	return false
}

func (m *RouterRequest) GetCursor() string {
	if m != nil {
		return m.Cursor
	}
	return ""
}

func (m *RouterRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *RouterRequest) GetWithReversible() bool {
	if m != nil {
		return m.WithReversible
	}
	return false
}

func (m *RouterRequest) GetMode() RouterRequest_Mode {
	if m != nil {
		return m.Mode
	}
	return RouterRequest_STREAMING
}

func (m *RouterRequest) GetUseLegacyBoundaries() bool {
	if m != nil {
		return m.UseLegacyBoundaries
	}
	return false
}

func (m *RouterRequest) GetStartBlock() uint64 {
	if m != nil {
		return m.StartBlock
	}
	return 0
}

func (m *RouterRequest) GetBlockCount() uint64 {
	if m != nil {
		return m.BlockCount
	}
	return 0
}

func (m *RouterRequest) GetLiveMarkerInterval() uint64 {
	if m != nil {
		return m.LiveMarkerInterval
	}
	return 0
}

type SearchMatch struct {
	TrxIdPrefix string `protobuf:"bytes,1,opt,name=trxIdPrefix,proto3" json:"trxIdPrefix,omitempty"`
	BlockNum    uint64 `protobuf:"varint,2,opt,name=blockNum,proto3" json:"blockNum,omitempty"`
	Index       uint64 `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	Cursor      string `protobuf:"bytes,4,opt,name=cursor,proto3" json:"cursor,omitempty"`
	// Types that are valid to be assigned to Specific:
	//	*SearchMatch_Eos
	//	*SearchMatch_Eth
	Specific             isSearchMatch_Specific `protobuf_oneof:"specific"`
	Undo                 bool                   `protobuf:"varint,25,opt,name=undo,proto3" json:"undo,omitempty"`
	IrrBlockNum          uint64                 `protobuf:"varint,26,opt,name=irrBlockNum,proto3" json:"irrBlockNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *SearchMatch) Reset()         { *m = SearchMatch{} }
func (m *SearchMatch) String() string { return proto.CompactTextString(m) }
func (*SearchMatch) ProtoMessage()    {}
func (*SearchMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{4}
}

func (m *SearchMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SearchMatch.Unmarshal(m, b)
}
func (m *SearchMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SearchMatch.Marshal(b, m, deterministic)
}
func (m *SearchMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchMatch.Merge(m, src)
}
func (m *SearchMatch) XXX_Size() int {
	return xxx_messageInfo_SearchMatch.Size(m)
}
func (m *SearchMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchMatch.DiscardUnknown(m)
}

var xxx_messageInfo_SearchMatch proto.InternalMessageInfo

func (m *SearchMatch) GetTrxIdPrefix() string {
	if m != nil {
		return m.TrxIdPrefix
	}
	return ""
}

func (m *SearchMatch) GetBlockNum() uint64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *SearchMatch) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SearchMatch) GetCursor() string {
	if m != nil {
		return m.Cursor
	}
	return ""
}

type isSearchMatch_Specific interface {
	isSearchMatch_Specific()
}

type SearchMatch_Eos struct {
	Eos *EOSMatch `protobuf:"bytes,10,opt,name=eos,proto3,oneof"`
}

type SearchMatch_Eth struct {
	Eth *ETHMatch `protobuf:"bytes,11,opt,name=eth,proto3,oneof"`
}

func (*SearchMatch_Eos) isSearchMatch_Specific() {}

func (*SearchMatch_Eth) isSearchMatch_Specific() {}

func (m *SearchMatch) GetSpecific() isSearchMatch_Specific {
	if m != nil {
		return m.Specific
	}
	return nil
}

func (m *SearchMatch) GetEos() *EOSMatch {
	if x, ok := m.GetSpecific().(*SearchMatch_Eos); ok {
		return x.Eos
	}
	return nil
}

func (m *SearchMatch) GetEth() *ETHMatch {
	if x, ok := m.GetSpecific().(*SearchMatch_Eth); ok {
		return x.Eth
	}
	return nil
}

func (m *SearchMatch) GetUndo() bool {
	if m != nil {
		return m.Undo
	}
	return false
}

func (m *SearchMatch) GetIrrBlockNum() uint64 {
	if m != nil {
		return m.IrrBlockNum
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SearchMatch) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SearchMatch_Eos)(nil),
		(*SearchMatch_Eth)(nil),
	}
}

type EOSDocumentID struct {
	BlockNum             uint64   `protobuf:"varint,1,opt,name=blockNum,proto3" json:"blockNum,omitempty"`
	ActionIndex          uint64   `protobuf:"varint,2,opt,name=actionIndex,proto3" json:"actionIndex,omitempty"`
	TransactionIndex     uint64   `protobuf:"varint,3,opt,name=transactionIndex,proto3" json:"transactionIndex,omitempty"`
	TransactionIDPrefix  []byte   `protobuf:"bytes,4,opt,name=transactionIDPrefix,proto3" json:"transactionIDPrefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EOSDocumentID) Reset()         { *m = EOSDocumentID{} }
func (m *EOSDocumentID) String() string { return proto.CompactTextString(m) }
func (*EOSDocumentID) ProtoMessage()    {}
func (*EOSDocumentID) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{5}
}

func (m *EOSDocumentID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EOSDocumentID.Unmarshal(m, b)
}
func (m *EOSDocumentID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EOSDocumentID.Marshal(b, m, deterministic)
}
func (m *EOSDocumentID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EOSDocumentID.Merge(m, src)
}
func (m *EOSDocumentID) XXX_Size() int {
	return xxx_messageInfo_EOSDocumentID.Size(m)
}
func (m *EOSDocumentID) XXX_DiscardUnknown() {
	xxx_messageInfo_EOSDocumentID.DiscardUnknown(m)
}

var xxx_messageInfo_EOSDocumentID proto.InternalMessageInfo

func (m *EOSDocumentID) GetBlockNum() uint64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *EOSDocumentID) GetActionIndex() uint64 {
	if m != nil {
		return m.ActionIndex
	}
	return 0
}

func (m *EOSDocumentID) GetTransactionIndex() uint64 {
	if m != nil {
		return m.TransactionIndex
	}
	return 0
}

func (m *EOSDocumentID) GetTransactionIDPrefix() []byte {
	if m != nil {
		return m.TransactionIDPrefix
	}
	return nil
}

type EOSMatch struct {
	ActionIndexes        []uint32            `protobuf:"varint,1,rep,packed,name=actionIndexes,proto3" json:"actionIndexes,omitempty"`
	Block                *EOSBlockTrxPayload `protobuf:"bytes,8,opt,name=block,proto3" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *EOSMatch) Reset()         { *m = EOSMatch{} }
func (m *EOSMatch) String() string { return proto.CompactTextString(m) }
func (*EOSMatch) ProtoMessage()    {}
func (*EOSMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{6}
}

func (m *EOSMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EOSMatch.Unmarshal(m, b)
}
func (m *EOSMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EOSMatch.Marshal(b, m, deterministic)
}
func (m *EOSMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EOSMatch.Merge(m, src)
}
func (m *EOSMatch) XXX_Size() int {
	return xxx_messageInfo_EOSMatch.Size(m)
}
func (m *EOSMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EOSMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EOSMatch proto.InternalMessageInfo

func (m *EOSMatch) GetActionIndexes() []uint32 {
	if m != nil {
		return m.ActionIndexes
	}
	return nil
}

func (m *EOSMatch) GetBlock() *EOSBlockTrxPayload {
	if m != nil {
		return m.Block
	}
	return nil
}

type EOSBlockTrxPayload struct {
	BlockHeader          *deos.BlockHeader      `protobuf:"bytes,1,opt,name=blockHeader,proto3" json:"blockHeader,omitempty"`
	BlockID              string                 `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	Trace                *deos.TransactionTrace `protobuf:"bytes,6,opt,name=trace,proto3" json:"trace,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *EOSBlockTrxPayload) Reset()         { *m = EOSBlockTrxPayload{} }
func (m *EOSBlockTrxPayload) String() string { return proto.CompactTextString(m) }
func (*EOSBlockTrxPayload) ProtoMessage()    {}
func (*EOSBlockTrxPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{7}
}

func (m *EOSBlockTrxPayload) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EOSBlockTrxPayload.Unmarshal(m, b)
}
func (m *EOSBlockTrxPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EOSBlockTrxPayload.Marshal(b, m, deterministic)
}
func (m *EOSBlockTrxPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EOSBlockTrxPayload.Merge(m, src)
}
func (m *EOSBlockTrxPayload) XXX_Size() int {
	return xxx_messageInfo_EOSBlockTrxPayload.Size(m)
}
func (m *EOSBlockTrxPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_EOSBlockTrxPayload.DiscardUnknown(m)
}

var xxx_messageInfo_EOSBlockTrxPayload proto.InternalMessageInfo

func (m *EOSBlockTrxPayload) GetBlockHeader() *deos.BlockHeader {
	if m != nil {
		return m.BlockHeader
	}
	return nil
}

func (m *EOSBlockTrxPayload) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *EOSBlockTrxPayload) GetTrace() *deos.TransactionTrace {
	if m != nil {
		return m.Trace
	}
	return nil
}

type ETHMatch struct {
	CallIndexes          []uint32            `protobuf:"varint,1,rep,packed,name=callIndexes,proto3" json:"callIndexes,omitempty"`
	LogIndexes           []uint32            `protobuf:"varint,2,rep,packed,name=logIndexes,proto3" json:"logIndexes,omitempty"`
	Block                *ETHBlockTrxPayload `protobuf:"bytes,8,opt,name=block,proto3" json:"block,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ETHMatch) Reset()         { *m = ETHMatch{} }
func (m *ETHMatch) String() string { return proto.CompactTextString(m) }
func (*ETHMatch) ProtoMessage()    {}
func (*ETHMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{8}
}

func (m *ETHMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ETHMatch.Unmarshal(m, b)
}
func (m *ETHMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ETHMatch.Marshal(b, m, deterministic)
}
func (m *ETHMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ETHMatch.Merge(m, src)
}
func (m *ETHMatch) XXX_Size() int {
	return xxx_messageInfo_ETHMatch.Size(m)
}
func (m *ETHMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ETHMatch.DiscardUnknown(m)
}

var xxx_messageInfo_ETHMatch proto.InternalMessageInfo

func (m *ETHMatch) GetCallIndexes() []uint32 {
	if m != nil {
		return m.CallIndexes
	}
	return nil
}

func (m *ETHMatch) GetLogIndexes() []uint32 {
	if m != nil {
		return m.LogIndexes
	}
	return nil
}

func (m *ETHMatch) GetBlock() *ETHBlockTrxPayload {
	if m != nil {
		return m.Block
	}
	return nil
}

type ETHBlockTrxPayload struct {
	// Expected to be a deth.BlockHeader
	BlockHeader []byte `protobuf:"bytes,1,opt,name=blockHeader,proto3" json:"blockHeader,omitempty"`
	BlockID     string `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	BlockNum    uint64 `protobuf:"varint,3,opt,name=blockNum,proto3" json:"blockNum,omitempty"`
	// Expected to be a deth.SignedTransaction
	Trace                []byte   `protobuf:"bytes,10,opt,name=trace,proto3" json:"trace,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ETHBlockTrxPayload) Reset()         { *m = ETHBlockTrxPayload{} }
func (m *ETHBlockTrxPayload) String() string { return proto.CompactTextString(m) }
func (*ETHBlockTrxPayload) ProtoMessage()    {}
func (*ETHBlockTrxPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{9}
}

func (m *ETHBlockTrxPayload) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ETHBlockTrxPayload.Unmarshal(m, b)
}
func (m *ETHBlockTrxPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ETHBlockTrxPayload.Marshal(b, m, deterministic)
}
func (m *ETHBlockTrxPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ETHBlockTrxPayload.Merge(m, src)
}
func (m *ETHBlockTrxPayload) XXX_Size() int {
	return xxx_messageInfo_ETHBlockTrxPayload.Size(m)
}
func (m *ETHBlockTrxPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_ETHBlockTrxPayload.DiscardUnknown(m)
}

var xxx_messageInfo_ETHBlockTrxPayload proto.InternalMessageInfo

func (m *ETHBlockTrxPayload) GetBlockHeader() []byte {
	if m != nil {
		return m.BlockHeader
	}
	return nil
}

func (m *ETHBlockTrxPayload) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

func (m *ETHBlockTrxPayload) GetBlockNum() uint64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *ETHBlockTrxPayload) GetTrace() []byte {
	if m != nil {
		return m.Trace
	}
	return nil
}

func init() {
	proto.RegisterEnum("dfuse.search.v1.RouterRequest_Mode", RouterRequest_Mode_name, RouterRequest_Mode_value)
	proto.RegisterType((*ForkResolveRequest)(nil), "dfuse.search.v1.ForkResolveRequest")
	proto.RegisterType((*BlockRef)(nil), "dfuse.search.v1.BlockRef")
	proto.RegisterType((*BackendRequest)(nil), "dfuse.search.v1.BackendRequest")
	proto.RegisterType((*RouterRequest)(nil), "dfuse.search.v1.RouterRequest")
	proto.RegisterType((*SearchMatch)(nil), "dfuse.search.v1.SearchMatch")
	proto.RegisterType((*EOSDocumentID)(nil), "dfuse.search.v1.EOSDocumentID")
	proto.RegisterType((*EOSMatch)(nil), "dfuse.search.v1.EOSMatch")
	proto.RegisterType((*EOSBlockTrxPayload)(nil), "dfuse.search.v1.EOSBlockTrxPayload")
	proto.RegisterType((*ETHMatch)(nil), "dfuse.search.v1.ETHMatch")
	proto.RegisterType((*ETHBlockTrxPayload)(nil), "dfuse.search.v1.ETHBlockTrxPayload")
}

func init() { proto.RegisterFile("dfuse/search/v1/search.proto", fileDescriptor_5a664997e27fcf00) }

var fileDescriptor_5a664997e27fcf00 = []byte{
	// 1004 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdd, 0x6e, 0xdb, 0x36,
	0x14, 0xae, 0x2d, 0x25, 0x51, 0x8e, 0xed, 0xd4, 0xe1, 0x82, 0x41, 0x09, 0x8a, 0xcc, 0xd0, 0x8a,
	0xc1, 0x28, 0x5a, 0xbb, 0xf5, 0x2e, 0x86, 0xdd, 0x35, 0xae, 0xdd, 0xc6, 0xc1, 0xf2, 0x03, 0xda,
	0x1d, 0xf6, 0x73, 0x25, 0x4b, 0xb4, 0x2d, 0x58, 0x16, 0x13, 0x8a, 0x72, 0x93, 0x37, 0xd8, 0xcd,
	0x9e, 0x61, 0x0f, 0xb0, 0x07, 0xd8, 0xed, 0x1e, 0x6b, 0x97, 0x03, 0x8f, 0x64, 0x5b, 0xb6, 0x94,
	0xa4, 0xbd, 0x11, 0xc4, 0xef, 0x7c, 0x24, 0x0f, 0xbf, 0xf3, 0x43, 0xc2, 0x33, 0x77, 0x14, 0x85,
	0xac, 0x19, 0x32, 0x5b, 0x38, 0x93, 0xe6, 0xfc, 0x4d, 0xf2, 0xd7, 0xb8, 0x16, 0x5c, 0x72, 0xf2,
	0x14, 0xad, 0x8d, 0x04, 0x9b, 0xbf, 0x39, 0x4a, 0xe8, 0x0e, 0x77, 0x99, 0x13, 0x36, 0x5d, 0xc6,
	0xe3, 0x4f, 0x4c, 0xb7, 0x38, 0x90, 0xf7, 0x5c, 0x4c, 0x29, 0x0b, 0xb9, 0x3f, 0x67, 0x94, 0xdd,
	0x44, 0x2c, 0x94, 0xe4, 0x00, 0xb6, 0x6e, 0x22, 0x26, 0xee, 0xcc, 0x42, 0xad, 0x50, 0xdf, 0xa5,
	0xf1, 0x80, 0xbc, 0x83, 0xa7, 0x23, 0x2e, 0xa6, 0xcc, 0x6d, 0xfb, 0xdc, 0x99, 0x52, 0x36, 0x0a,
	0xcd, 0x62, 0x4d, 0xab, 0x97, 0x5a, 0x87, 0x8d, 0x8d, 0x4d, 0x1b, 0x0b, 0x06, 0xdd, 0x9c, 0x61,
	0xbd, 0x05, 0x63, 0x31, 0x20, 0x47, 0x60, 0x0c, 0xd5, 0xff, 0x45, 0x34, 0xc3, 0x9d, 0x74, 0xba,
	0x1c, 0x13, 0x13, 0x76, 0xf0, 0xbf, 0xd7, 0x31, 0x8b, 0xe8, 0xc4, 0x62, 0x68, 0xfd, 0x57, 0x84,
	0xbd, 0xb6, 0xed, 0x4c, 0x59, 0xe0, 0x3e, 0xec, 0x6f, 0x0d, 0x4a, 0x3e, 0xff, 0xd4, 0x5e, 0xec,
	0x50, 0xc4, 0x1d, 0xd2, 0x10, 0xb1, 0xa0, 0x3c, 0xf1, 0xc6, 0x93, 0x25, 0x45, 0x43, 0xca, 0x1a,
	0x46, 0x8e, 0x01, 0x5c, 0x16, 0x3a, 0x2c, 0x70, 0xbd, 0x60, 0x6c, 0xea, 0xb5, 0x42, 0xdd, 0xa0,
	0x29, 0x84, 0x7c, 0x07, 0x7b, 0x9f, 0x3c, 0x39, 0xa1, 0x6c, 0xce, 0x44, 0xe8, 0x0d, 0x7d, 0x66,
	0x6e, 0x21, 0x67, 0x03, 0x25, 0x0d, 0x20, 0xbe, 0x37, 0x67, 0xe7, 0xb6, 0x98, 0x32, 0xd1, 0x0b,
	0x24, 0x13, 0x73, 0xdb, 0x37, 0xb7, 0x71, 0xc7, 0x1c, 0x0b, 0x79, 0x09, 0xfb, 0xa1, 0xe4, 0xd7,
	0x27, 0xf2, 0x67, 0x4f, 0xc8, 0xc8, 0xf6, 0x4f, 0x99, 0xed, 0x9a, 0x3b, 0xb8, 0x74, 0xd6, 0x40,
	0x5e, 0xc3, 0x57, 0x81, 0x3d, 0xf7, 0xc6, 0xb6, 0x64, 0xef, 0x05, 0x9f, 0xb5, 0x13, 0xe9, 0x0c,
	0xd4, 0x23, 0xcf, 0x44, 0x5a, 0x70, 0x90, 0x81, 0x95, 0x06, 0xbb, 0xe8, 0x51, 0xae, 0xcd, 0xfa,
	0x57, 0x87, 0x0a, 0xe5, 0x91, 0x64, 0xe2, 0x8b, 0x95, 0xd7, 0x1e, 0x57, 0x5e, 0xdb, 0x50, 0xfe,
	0x25, 0xec, 0x2f, 0xa6, 0x7c, 0x0c, 0x86, 0x3c, 0x0a, 0x5c, 0xe6, 0x9a, 0x95, 0x58, 0x81, 0x8c,
	0x41, 0xe9, 0xbb, 0x9c, 0xbd, 0xa2, 0xef, 0x21, 0x3d, 0xc7, 0xf2, 0x68, 0x5c, 0xbf, 0x86, 0x6d,
	0x27, 0x12, 0x21, 0x17, 0x18, 0xcf, 0x5d, 0x9a, 0x8c, 0xd4, 0x89, 0x7d, 0x6f, 0xe6, 0x49, 0x0c,
	0x9d, 0x46, 0xe3, 0x41, 0x4e, 0x16, 0xec, 0xe4, 0x66, 0xc1, 0x0f, 0xa0, 0xcf, 0xb8, 0xcb, 0x30,
	0x30, 0x7b, 0xad, 0x6f, 0x33, 0x85, 0xb3, 0xa6, 0x6e, 0xe3, 0x9c, 0xbb, 0x8c, 0xe2, 0x04, 0x15,
	0xe0, 0x28, 0x64, 0x3f, 0xb1, 0xb1, 0xed, 0xdc, 0xb5, 0xd5, 0x11, 0x6c, 0xe1, 0xb1, 0x10, 0xa3,
	0x65, 0xd0, 0x3c, 0x93, 0x3a, 0x60, 0x28, 0x6d, 0x21, 0xf1, 0xdc, 0x26, 0x60, 0x58, 0x53, 0x88,
	0xb2, 0x63, 0x49, 0xbd, 0xe3, 0x51, 0x20, 0xcd, 0x52, 0x6c, 0x5f, 0x21, 0xf7, 0x24, 0x6c, 0xf9,
	0xbe, 0x84, 0xb5, 0x9e, 0x83, 0xae, 0xfc, 0x25, 0x15, 0xd8, 0xed, 0x0f, 0x68, 0xf7, 0xe4, 0xbc,
	0x77, 0xf1, 0xa1, 0xfa, 0x44, 0x0d, 0xaf, 0x4e, 0x3e, 0xf4, 0x2e, 0x4e, 0x06, 0xdd, 0x4e, 0xb5,
	0x60, 0xfd, 0x55, 0x84, 0x52, 0x1f, 0x8f, 0x7b, 0x6e, 0x4b, 0x67, 0xa2, 0x52, 0x45, 0x8a, 0xdb,
	0x9e, 0x7b, 0x25, 0xd8, 0xc8, 0xbb, 0x4d, 0xd2, 0x28, 0x0d, 0xad, 0x75, 0x89, 0xe2, 0x46, 0x97,
	0x38, 0x80, 0x2d, 0x2f, 0x70, 0xd9, 0x6d, 0x52, 0xb9, 0xf1, 0x20, 0x15, 0x3a, 0x7d, 0x2d, 0x74,
	0xaf, 0x40, 0x63, 0x3c, 0x44, 0x29, 0xf2, 0x9a, 0x56, 0xf7, 0xb2, 0x8f, 0x3e, 0x9d, 0x3e, 0xa1,
	0x8a, 0x87, 0x74, 0x39, 0x41, 0x65, 0x72, 0xe9, 0x83, 0xd3, 0x15, 0x5d, 0x4e, 0x08, 0x01, 0x3d,
	0x0a, 0x5c, 0x6e, 0x1e, 0x62, 0x48, 0xf0, 0x5f, 0x9d, 0xce, 0x13, 0x62, 0x99, 0xe5, 0x47, 0x71,
	0x0b, 0x4a, 0x41, 0x6d, 0x00, 0x23, 0xbc, 0x66, 0x8e, 0x37, 0xf2, 0x9c, 0x33, 0xdd, 0xa8, 0x54,
	0x0f, 0xad, 0xbf, 0x0b, 0x50, 0xe9, 0x5e, 0xf6, 0x3b, 0xdc, 0x89, 0x66, 0x2c, 0x90, 0xbd, 0xce,
	0x83, 0x7d, 0xb2, 0x06, 0x25, 0xdb, 0x91, 0x1e, 0x0f, 0x7a, 0xa8, 0x43, 0xd2, 0xe4, 0x52, 0x10,
	0x79, 0x01, 0x55, 0x29, 0xec, 0x20, 0x4c, 0xd3, 0x62, 0xb9, 0x32, 0xb8, 0xca, 0xb2, 0x34, 0xd6,
	0x49, 0xa2, 0xa2, 0x64, 0x2c, 0xd3, 0x3c, 0x93, 0x75, 0x03, 0xc6, 0x42, 0x37, 0xf2, 0x1c, 0x2a,
	0xa9, 0xc5, 0x58, 0x68, 0x16, 0x6a, 0x5a, 0xbd, 0x42, 0xd7, 0x41, 0xf2, 0x23, 0x6c, 0xa1, 0xf7,
	0x58, 0x03, 0xa5, 0x9c, 0x1a, 0xe8, 0x5e, 0xf6, 0x51, 0x9e, 0x81, 0xb8, 0xbd, 0xb2, 0xef, 0x7c,
	0x6e, 0xbb, 0x34, 0x9e, 0x71, 0xa6, 0x1b, 0xc5, 0xaa, 0x61, 0xfd, 0x53, 0x00, 0x92, 0xe5, 0x90,
	0xb7, 0x50, 0x42, 0x96, 0xea, 0x87, 0x4c, 0xa0, 0x50, 0xa5, 0xd6, 0x71, 0xb2, 0x7a, 0x7c, 0xfd,
	0x35, 0xf0, 0xe6, 0x6b, 0xaf, 0x58, 0x34, 0x3d, 0xe5, 0xfe, 0x3b, 0x47, 0xf9, 0x2c, 0x85, 0xed,
	0x30, 0x2c, 0xfa, 0x95, 0xcf, 0xe9, 0x55, 0x07, 0x2b, 0x71, 0x06, 0x8a, 0x4a, 0xe3, 0x19, 0x67,
	0xba, 0xa1, 0x55, 0xb7, 0xcf, 0x74, 0x63, 0xa7, 0x5a, 0xb6, 0xfe, 0x2c, 0x80, 0xb1, 0x48, 0x1b,
	0x15, 0x39, 0xc7, 0xf6, 0xfd, 0x75, 0xad, 0xd2, 0x90, 0xaa, 0x50, 0x9f, 0x8f, 0x17, 0x84, 0x22,
	0x12, 0x52, 0xc8, 0x67, 0x28, 0x39, 0x38, 0xbd, 0x57, 0x49, 0xad, 0x6a, 0x58, 0x7f, 0x28, 0x25,
	0x33, 0x1c, 0xe5, 0xd9, 0xa6, 0x92, 0xe5, 0xcf, 0x55, 0x2a, 0x9d, 0xab, 0x5a, 0xb6, 0x5a, 0x63,
	0x15, 0x01, 0x57, 0x5c, 0x0a, 0xa4, 0x57, 0xa1, 0xf5, 0x3b, 0xec, 0x24, 0x97, 0x3a, 0xb9, 0x82,
	0x4a, 0x5f, 0x0a, 0x66, 0xcf, 0x50, 0x27, 0x16, 0x92, 0x6f, 0xb2, 0xef, 0x8b, 0xb5, 0xfb, 0xff,
	0xe8, 0x59, 0x86, 0x90, 0x6a, 0x31, 0xaf, 0x0b, 0xad, 0x5f, 0x61, 0x3b, 0x6e, 0xac, 0xe4, 0x72,
	0x73, 0xed, 0xe3, 0x87, 0x5b, 0xf0, 0xa3, 0x4b, 0x4f, 0xa0, 0x9c, 0x7a, 0x40, 0x09, 0xf2, 0x0b,
	0xec, 0xc7, 0x1b, 0x7c, 0x0c, 0x5c, 0xbe, 0xd8, 0x24, 0x1b, 0x99, 0xec, 0xa3, 0xeb, 0xb1, 0x9d,
	0xda, 0x2f, 0x7e, 0xab, 0x8f, 0x3d, 0x39, 0x89, 0x86, 0x0d, 0x87, 0xcf, 0x9a, 0xc8, 0x7d, 0xe5,
	0xf1, 0xe6, 0xf5, 0x70, 0xcc, 0x9b, 0x1b, 0x4f, 0xc2, 0xe1, 0x36, 0xbe, 0xee, 0xbe, 0xff, 0x3f,
	0x00, 0x00, 0xff, 0xff, 0xa5, 0xd2, 0x7c, 0x30, 0x2c, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BackendClient is the client API for Backend service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BackendClient interface {
	StreamMatches(ctx context.Context, in *BackendRequest, opts ...grpc.CallOption) (Backend_StreamMatchesClient, error)
}

type backendClient struct {
	cc *grpc.ClientConn
}

func NewBackendClient(cc *grpc.ClientConn) BackendClient {
	return &backendClient{cc}
}

func (c *backendClient) StreamMatches(ctx context.Context, in *BackendRequest, opts ...grpc.CallOption) (Backend_StreamMatchesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Backend_serviceDesc.Streams[0], "/dfuse.search.v1.Backend/StreamMatches", opts...)
	if err != nil {
		return nil, err
	}
	x := &backendStreamMatchesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Backend_StreamMatchesClient interface {
	Recv() (*SearchMatch, error)
	grpc.ClientStream
}

type backendStreamMatchesClient struct {
	grpc.ClientStream
}

func (x *backendStreamMatchesClient) Recv() (*SearchMatch, error) {
	m := new(SearchMatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BackendServer is the server API for Backend service.
type BackendServer interface {
	StreamMatches(*BackendRequest, Backend_StreamMatchesServer) error
}

// UnimplementedBackendServer can be embedded to have forward compatible implementations.
type UnimplementedBackendServer struct {
}

func (*UnimplementedBackendServer) StreamMatches(req *BackendRequest, srv Backend_StreamMatchesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamMatches not implemented")
}

func RegisterBackendServer(s *grpc.Server, srv BackendServer) {
	s.RegisterService(&_Backend_serviceDesc, srv)
}

func _Backend_StreamMatches_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BackendRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackendServer).StreamMatches(m, &backendStreamMatchesServer{stream})
}

type Backend_StreamMatchesServer interface {
	Send(*SearchMatch) error
	grpc.ServerStream
}

type backendStreamMatchesServer struct {
	grpc.ServerStream
}

func (x *backendStreamMatchesServer) Send(m *SearchMatch) error {
	return x.ServerStream.SendMsg(m)
}

var _Backend_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dfuse.search.v1.Backend",
	HandlerType: (*BackendServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMatches",
			Handler:       _Backend_StreamMatches_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dfuse/search/v1/search.proto",
}

// RouterClient is the client API for Router service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RouterClient interface {
	StreamMatches(ctx context.Context, in *RouterRequest, opts ...grpc.CallOption) (Router_StreamMatchesClient, error)
}

type routerClient struct {
	cc *grpc.ClientConn
}

func NewRouterClient(cc *grpc.ClientConn) RouterClient {
	return &routerClient{cc}
}

func (c *routerClient) StreamMatches(ctx context.Context, in *RouterRequest, opts ...grpc.CallOption) (Router_StreamMatchesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Router_serviceDesc.Streams[0], "/dfuse.search.v1.Router/StreamMatches", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerStreamMatchesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Router_StreamMatchesClient interface {
	Recv() (*SearchMatch, error)
	grpc.ClientStream
}

type routerStreamMatchesClient struct {
	grpc.ClientStream
}

func (x *routerStreamMatchesClient) Recv() (*SearchMatch, error) {
	m := new(SearchMatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RouterServer is the server API for Router service.
type RouterServer interface {
	StreamMatches(*RouterRequest, Router_StreamMatchesServer) error
}

// UnimplementedRouterServer can be embedded to have forward compatible implementations.
type UnimplementedRouterServer struct {
}

func (*UnimplementedRouterServer) StreamMatches(req *RouterRequest, srv Router_StreamMatchesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamMatches not implemented")
}

func RegisterRouterServer(s *grpc.Server, srv RouterServer) {
	s.RegisterService(&_Router_serviceDesc, srv)
}

func _Router_StreamMatches_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouterRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterServer).StreamMatches(m, &routerStreamMatchesServer{stream})
}

type Router_StreamMatchesServer interface {
	Send(*SearchMatch) error
	grpc.ServerStream
}

type routerStreamMatchesServer struct {
	grpc.ServerStream
}

func (x *routerStreamMatchesServer) Send(m *SearchMatch) error {
	return x.ServerStream.SendMsg(m)
}

var _Router_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dfuse.search.v1.Router",
	HandlerType: (*RouterServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMatches",
			Handler:       _Router_StreamMatches_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dfuse/search/v1/search.proto",
}

// ForkResolverClient is the client API for ForkResolver service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ForkResolverClient interface {
	StreamUndoMatches(ctx context.Context, in *ForkResolveRequest, opts ...grpc.CallOption) (ForkResolver_StreamUndoMatchesClient, error)
}

type forkResolverClient struct {
	cc *grpc.ClientConn
}

func NewForkResolverClient(cc *grpc.ClientConn) ForkResolverClient {
	return &forkResolverClient{cc}
}

func (c *forkResolverClient) StreamUndoMatches(ctx context.Context, in *ForkResolveRequest, opts ...grpc.CallOption) (ForkResolver_StreamUndoMatchesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ForkResolver_serviceDesc.Streams[0], "/dfuse.search.v1.ForkResolver/StreamUndoMatches", opts...)
	if err != nil {
		return nil, err
	}
	x := &forkResolverStreamUndoMatchesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ForkResolver_StreamUndoMatchesClient interface {
	Recv() (*SearchMatch, error)
	grpc.ClientStream
}

type forkResolverStreamUndoMatchesClient struct {
	grpc.ClientStream
}

func (x *forkResolverStreamUndoMatchesClient) Recv() (*SearchMatch, error) {
	m := new(SearchMatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ForkResolverServer is the server API for ForkResolver service.
type ForkResolverServer interface {
	StreamUndoMatches(*ForkResolveRequest, ForkResolver_StreamUndoMatchesServer) error
}

// UnimplementedForkResolverServer can be embedded to have forward compatible implementations.
type UnimplementedForkResolverServer struct {
}

func (*UnimplementedForkResolverServer) StreamUndoMatches(req *ForkResolveRequest, srv ForkResolver_StreamUndoMatchesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamUndoMatches not implemented")
}

func RegisterForkResolverServer(s *grpc.Server, srv ForkResolverServer) {
	s.RegisterService(&_ForkResolver_serviceDesc, srv)
}

func _ForkResolver_StreamUndoMatches_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ForkResolveRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ForkResolverServer).StreamUndoMatches(m, &forkResolverStreamUndoMatchesServer{stream})
}

type ForkResolver_StreamUndoMatchesServer interface {
	Send(*SearchMatch) error
	grpc.ServerStream
}

type forkResolverStreamUndoMatchesServer struct {
	grpc.ServerStream
}

func (x *forkResolverStreamUndoMatchesServer) Send(m *SearchMatch) error {
	return x.ServerStream.SendMsg(m)
}

var _ForkResolver_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dfuse.search.v1.ForkResolver",
	HandlerType: (*ForkResolverServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamUndoMatches",
			Handler:       _ForkResolver_StreamUndoMatches_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dfuse/search/v1/search.proto",
}
