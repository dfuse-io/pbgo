// Code generated by protoc-gen-go. DO NOT EDIT.
// source: dfuse/search/v1/search.proto

package pbsearch

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type RouterRequest_Mode int32

const (
	RouterRequest_STREAMING RouterRequest_Mode = 0
	RouterRequest_PAGINATED RouterRequest_Mode = 1
)

var RouterRequest_Mode_name = map[int32]string{
	0: "STREAMING",
	1: "PAGINATED",
}

var RouterRequest_Mode_value = map[string]int32{
	"STREAMING": 0,
	"PAGINATED": 1,
}

func (x RouterRequest_Mode) String() string {
	return proto.EnumName(RouterRequest_Mode_name, int32(x))
}

func (RouterRequest_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{3, 0}
}

type ForkResolveRequest struct {
	Query                string      `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	ForkedBlockRefs      []*BlockRef `protobuf:"bytes,2,rep,name=forkedBlockRefs,proto3" json:"forkedBlockRefs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ForkResolveRequest) Reset()         { *m = ForkResolveRequest{} }
func (m *ForkResolveRequest) String() string { return proto.CompactTextString(m) }
func (*ForkResolveRequest) ProtoMessage()    {}
func (*ForkResolveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{0}
}

func (m *ForkResolveRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ForkResolveRequest.Unmarshal(m, b)
}
func (m *ForkResolveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ForkResolveRequest.Marshal(b, m, deterministic)
}
func (m *ForkResolveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForkResolveRequest.Merge(m, src)
}
func (m *ForkResolveRequest) XXX_Size() int {
	return xxx_messageInfo_ForkResolveRequest.Size(m)
}
func (m *ForkResolveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ForkResolveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ForkResolveRequest proto.InternalMessageInfo

func (m *ForkResolveRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *ForkResolveRequest) GetForkedBlockRefs() []*BlockRef {
	if m != nil {
		return m.ForkedBlockRefs
	}
	return nil
}

type BlockRef struct {
	BlockNum             uint64   `protobuf:"varint,1,opt,name=blockNum,proto3" json:"blockNum,omitempty"`
	BlockID              string   `protobuf:"bytes,2,opt,name=blockID,proto3" json:"blockID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockRef) Reset()         { *m = BlockRef{} }
func (m *BlockRef) String() string { return proto.CompactTextString(m) }
func (*BlockRef) ProtoMessage()    {}
func (*BlockRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{1}
}

func (m *BlockRef) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BlockRef.Unmarshal(m, b)
}
func (m *BlockRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BlockRef.Marshal(b, m, deterministic)
}
func (m *BlockRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRef.Merge(m, src)
}
func (m *BlockRef) XXX_Size() int {
	return xxx_messageInfo_BlockRef.Size(m)
}
func (m *BlockRef) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRef.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRef proto.InternalMessageInfo

func (m *BlockRef) GetBlockNum() uint64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *BlockRef) GetBlockID() string {
	if m != nil {
		return m.BlockID
	}
	return ""
}

type BackendRequest struct {
	Query        string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	LowBlockNum  uint64 `protobuf:"varint,2,opt,name=lowBlockNum,proto3" json:"lowBlockNum,omitempty"`
	HighBlockNum uint64 `protobuf:"varint,3,opt,name=highBlockNum,proto3" json:"highBlockNum,omitempty"`
	Descending   bool   `protobuf:"varint,4,opt,name=descending,proto3" json:"descending,omitempty"`
	// More specific to the live / reversible backend
	WithReversible       bool     `protobuf:"varint,5,opt,name=withReversible,proto3" json:"withReversible,omitempty"`
	LiveMarkerInterval   uint64   `protobuf:"varint,6,opt,name=liveMarkerInterval,proto3" json:"liveMarkerInterval,omitempty"`
	StopAtVirtualHead    bool     `protobuf:"varint,7,opt,name=stopAtVirtualHead,proto3" json:"stopAtVirtualHead,omitempty"`
	NavigateFromBlockID  string   `protobuf:"bytes,8,opt,name=navigateFromBlockID,proto3" json:"navigateFromBlockID,omitempty"`
	NavigateFromBlockNum uint64   `protobuf:"varint,9,opt,name=navigateFromBlockNum,proto3" json:"navigateFromBlockNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackendRequest) Reset()         { *m = BackendRequest{} }
func (m *BackendRequest) String() string { return proto.CompactTextString(m) }
func (*BackendRequest) ProtoMessage()    {}
func (*BackendRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{2}
}

func (m *BackendRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BackendRequest.Unmarshal(m, b)
}
func (m *BackendRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BackendRequest.Marshal(b, m, deterministic)
}
func (m *BackendRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackendRequest.Merge(m, src)
}
func (m *BackendRequest) XXX_Size() int {
	return xxx_messageInfo_BackendRequest.Size(m)
}
func (m *BackendRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BackendRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BackendRequest proto.InternalMessageInfo

func (m *BackendRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *BackendRequest) GetLowBlockNum() uint64 {
	if m != nil {
		return m.LowBlockNum
	}
	return 0
}

func (m *BackendRequest) GetHighBlockNum() uint64 {
	if m != nil {
		return m.HighBlockNum
	}
	return 0
}

func (m *BackendRequest) GetDescending() bool {
	if m != nil {
		return m.Descending
	}
	return false
}

func (m *BackendRequest) GetWithReversible() bool {
	if m != nil {
		return m.WithReversible
	}
	return false
}

func (m *BackendRequest) GetLiveMarkerInterval() uint64 {
	if m != nil {
		return m.LiveMarkerInterval
	}
	return 0
}

func (m *BackendRequest) GetStopAtVirtualHead() bool {
	if m != nil {
		return m.StopAtVirtualHead
	}
	return false
}

func (m *BackendRequest) GetNavigateFromBlockID() string {
	if m != nil {
		return m.NavigateFromBlockID
	}
	return ""
}

func (m *BackendRequest) GetNavigateFromBlockNum() uint64 {
	if m != nil {
		return m.NavigateFromBlockNum
	}
	return 0
}

type RouterRequest struct {
	Query              string             `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	LowBlockNum        int64              `protobuf:"varint,2,opt,name=lowBlockNum,proto3" json:"lowBlockNum,omitempty"`
	HighBlockNum       int64              `protobuf:"varint,3,opt,name=highBlockNum,proto3" json:"highBlockNum,omitempty"`
	LowBlockUnbounded  bool               `protobuf:"varint,13,opt,name=lowBlockUnbounded,proto3" json:"lowBlockUnbounded,omitempty"`
	HighBlockUnbounded bool               `protobuf:"varint,14,opt,name=highBlockUnbounded,proto3" json:"highBlockUnbounded,omitempty"`
	Descending         bool               `protobuf:"varint,4,opt,name=descending,proto3" json:"descending,omitempty"`
	Cursor             string             `protobuf:"bytes,5,opt,name=cursor,proto3" json:"cursor,omitempty"`
	Limit              int64              `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	WithReversible     bool               `protobuf:"varint,7,opt,name=withReversible,proto3" json:"withReversible,omitempty"`
	Mode               RouterRequest_Mode `protobuf:"varint,8,opt,name=mode,proto3,enum=dfuse.search.v1.RouterRequest_Mode" json:"mode,omitempty"`
	// Legacy boundaries, overrides `lowBlockNum` and `highBlockNum`.
	UseLegacyBoundaries  bool     `protobuf:"varint,9,opt,name=useLegacyBoundaries,proto3" json:"useLegacyBoundaries,omitempty"`
	StartBlock           uint64   `protobuf:"varint,10,opt,name=startBlock,proto3" json:"startBlock,omitempty"`
	BlockCount           uint64   `protobuf:"varint,11,opt,name=blockCount,proto3" json:"blockCount,omitempty"`
	LiveMarkerInterval   uint64   `protobuf:"varint,12,opt,name=liveMarkerInterval,proto3" json:"liveMarkerInterval,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouterRequest) Reset()         { *m = RouterRequest{} }
func (m *RouterRequest) String() string { return proto.CompactTextString(m) }
func (*RouterRequest) ProtoMessage()    {}
func (*RouterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{3}
}

func (m *RouterRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RouterRequest.Unmarshal(m, b)
}
func (m *RouterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RouterRequest.Marshal(b, m, deterministic)
}
func (m *RouterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouterRequest.Merge(m, src)
}
func (m *RouterRequest) XXX_Size() int {
	return xxx_messageInfo_RouterRequest.Size(m)
}
func (m *RouterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RouterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RouterRequest proto.InternalMessageInfo

func (m *RouterRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *RouterRequest) GetLowBlockNum() int64 {
	if m != nil {
		return m.LowBlockNum
	}
	return 0
}

func (m *RouterRequest) GetHighBlockNum() int64 {
	if m != nil {
		return m.HighBlockNum
	}
	return 0
}

func (m *RouterRequest) GetLowBlockUnbounded() bool {
	if m != nil {
		return m.LowBlockUnbounded
	}
	return false
}

func (m *RouterRequest) GetHighBlockUnbounded() bool {
	if m != nil {
		return m.HighBlockUnbounded
	}
	return false
}

func (m *RouterRequest) GetDescending() bool {
	if m != nil {
		return m.Descending
	}
	return false
}

func (m *RouterRequest) GetCursor() string {
	if m != nil {
		return m.Cursor
	}
	return ""
}

func (m *RouterRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *RouterRequest) GetWithReversible() bool {
	if m != nil {
		return m.WithReversible
	}
	return false
}

func (m *RouterRequest) GetMode() RouterRequest_Mode {
	if m != nil {
		return m.Mode
	}
	return RouterRequest_STREAMING
}

func (m *RouterRequest) GetUseLegacyBoundaries() bool {
	if m != nil {
		return m.UseLegacyBoundaries
	}
	return false
}

func (m *RouterRequest) GetStartBlock() uint64 {
	if m != nil {
		return m.StartBlock
	}
	return 0
}

func (m *RouterRequest) GetBlockCount() uint64 {
	if m != nil {
		return m.BlockCount
	}
	return 0
}

func (m *RouterRequest) GetLiveMarkerInterval() uint64 {
	if m != nil {
		return m.LiveMarkerInterval
	}
	return 0
}

type SearchMatch struct {
	TrxIdPrefix string `protobuf:"bytes,1,opt,name=trxIdPrefix,proto3" json:"trxIdPrefix,omitempty"`
	BlockNum    uint64 `protobuf:"varint,2,opt,name=blockNum,proto3" json:"blockNum,omitempty"`
	Index       uint64 `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	Cursor      string `protobuf:"bytes,4,opt,name=cursor,proto3" json:"cursor,omitempty"`
	// Holds chain specific Protobuf message, this usually contains informations about how the
	// document are indexed (for example at the action level on EOSIO). Check out chain specific
	// repository for exact possible message.
	ChainSpecific        *any.Any `protobuf:"bytes,13,opt,name=chainSpecific,proto3" json:"chainSpecific,omitempty"`
	Undo                 bool     `protobuf:"varint,25,opt,name=undo,proto3" json:"undo,omitempty"`
	IrrBlockNum          uint64   `protobuf:"varint,26,opt,name=irrBlockNum,proto3" json:"irrBlockNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchMatch) Reset()         { *m = SearchMatch{} }
func (m *SearchMatch) String() string { return proto.CompactTextString(m) }
func (*SearchMatch) ProtoMessage()    {}
func (*SearchMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a664997e27fcf00, []int{4}
}

func (m *SearchMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SearchMatch.Unmarshal(m, b)
}
func (m *SearchMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SearchMatch.Marshal(b, m, deterministic)
}
func (m *SearchMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchMatch.Merge(m, src)
}
func (m *SearchMatch) XXX_Size() int {
	return xxx_messageInfo_SearchMatch.Size(m)
}
func (m *SearchMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchMatch.DiscardUnknown(m)
}

var xxx_messageInfo_SearchMatch proto.InternalMessageInfo

func (m *SearchMatch) GetTrxIdPrefix() string {
	if m != nil {
		return m.TrxIdPrefix
	}
	return ""
}

func (m *SearchMatch) GetBlockNum() uint64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *SearchMatch) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SearchMatch) GetCursor() string {
	if m != nil {
		return m.Cursor
	}
	return ""
}

func (m *SearchMatch) GetChainSpecific() *any.Any {
	if m != nil {
		return m.ChainSpecific
	}
	return nil
}

func (m *SearchMatch) GetUndo() bool {
	if m != nil {
		return m.Undo
	}
	return false
}

func (m *SearchMatch) GetIrrBlockNum() uint64 {
	if m != nil {
		return m.IrrBlockNum
	}
	return 0
}

func init() {
	proto.RegisterEnum("dfuse.search.v1.RouterRequest_Mode", RouterRequest_Mode_name, RouterRequest_Mode_value)
	proto.RegisterType((*ForkResolveRequest)(nil), "dfuse.search.v1.ForkResolveRequest")
	proto.RegisterType((*BlockRef)(nil), "dfuse.search.v1.BlockRef")
	proto.RegisterType((*BackendRequest)(nil), "dfuse.search.v1.BackendRequest")
	proto.RegisterType((*RouterRequest)(nil), "dfuse.search.v1.RouterRequest")
	proto.RegisterType((*SearchMatch)(nil), "dfuse.search.v1.SearchMatch")
}

func init() { proto.RegisterFile("dfuse/search/v1/search.proto", fileDescriptor_5a664997e27fcf00) }

var fileDescriptor_5a664997e27fcf00 = []byte{
	// 759 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0x5b, 0x6f, 0xea, 0x46,
	0x10, 0x2e, 0xe0, 0x70, 0x19, 0x2e, 0x87, 0x6c, 0x51, 0x65, 0xd0, 0xd1, 0x29, 0xa2, 0x55, 0x95,
	0x87, 0x53, 0x73, 0x42, 0x1e, 0x2a, 0xb5, 0x2f, 0x85, 0xdc, 0x4a, 0x54, 0xd2, 0xc8, 0x24, 0x55,
	0x2f, 0x4f, 0xbe, 0x0c, 0xf6, 0x0a, 0xe3, 0x25, 0xeb, 0x35, 0x09, 0xff, 0xae, 0xff, 0xaa, 0x7d,
	0xac, 0xbc, 0x06, 0x62, 0x30, 0x09, 0x3a, 0x6f, 0x3b, 0xf3, 0xcd, 0xee, 0xec, 0x7c, 0xf3, 0xed,
	0x2c, 0xbc, 0xb7, 0x27, 0x61, 0x80, 0xdd, 0x00, 0x0d, 0x6e, 0xb9, 0xdd, 0xc5, 0xe9, 0x6a, 0xa5,
	0xcd, 0x39, 0x13, 0x8c, 0xbc, 0x93, 0xa8, 0xb6, 0xf2, 0x2d, 0x4e, 0x5b, 0x4d, 0x87, 0x31, 0xc7,
	0xc3, 0xae, 0x84, 0xcd, 0x70, 0xd2, 0x35, 0xfc, 0x65, 0x1c, 0xdb, 0x61, 0x40, 0xae, 0x18, 0x9f,
	0xea, 0x18, 0x30, 0x6f, 0x81, 0x3a, 0x3e, 0x86, 0x18, 0x08, 0xd2, 0x80, 0xa3, 0xc7, 0x10, 0xf9,
	0x52, 0xcd, 0xb4, 0x33, 0x27, 0x25, 0x3d, 0x36, 0xc8, 0x39, 0xbc, 0x9b, 0x30, 0x3e, 0x45, 0x7b,
	0xe0, 0x31, 0x6b, 0xaa, 0xe3, 0x24, 0x50, 0xb3, 0xed, 0xdc, 0x49, 0xb9, 0xd7, 0xd4, 0x76, 0x32,
	0x6a, 0xeb, 0x08, 0x7d, 0x77, 0x47, 0xe7, 0x67, 0x28, 0xae, 0x0d, 0xd2, 0x82, 0xa2, 0x19, 0xad,
	0x6f, 0xc3, 0x99, 0xcc, 0xa4, 0xe8, 0x1b, 0x9b, 0xa8, 0x50, 0x90, 0xeb, 0xe1, 0x85, 0x9a, 0x95,
	0x97, 0x58, 0x9b, 0x9d, 0xff, 0xb2, 0x50, 0x1b, 0x18, 0xd6, 0x14, 0x7d, 0xfb, 0xed, 0xfb, 0xb6,
	0xa1, 0xec, 0xb1, 0xa7, 0xc1, 0x3a, 0x43, 0x56, 0x66, 0x48, 0xba, 0x48, 0x07, 0x2a, 0x2e, 0x75,
	0xdc, 0x4d, 0x48, 0x4e, 0x86, 0x6c, 0xf9, 0xc8, 0x07, 0x00, 0x1b, 0x03, 0x0b, 0x7d, 0x9b, 0xfa,
	0x8e, 0xaa, 0xb4, 0x33, 0x27, 0x45, 0x3d, 0xe1, 0x21, 0xdf, 0x41, 0xed, 0x89, 0x0a, 0x57, 0xc7,
	0x05, 0xf2, 0x80, 0x9a, 0x1e, 0xaa, 0x47, 0x32, 0x66, 0xc7, 0x4b, 0x34, 0x20, 0x1e, 0x5d, 0xe0,
	0xc8, 0xe0, 0x53, 0xe4, 0x43, 0x5f, 0x20, 0x5f, 0x18, 0x9e, 0x9a, 0x97, 0x19, 0xf7, 0x20, 0xe4,
	0x23, 0x1c, 0x07, 0x82, 0xcd, 0xfb, 0xe2, 0x77, 0xca, 0x45, 0x68, 0x78, 0xbf, 0xa0, 0x61, 0xab,
	0x05, 0x79, 0x74, 0x1a, 0x20, 0x9f, 0xe0, 0x4b, 0xdf, 0x58, 0x50, 0xc7, 0x10, 0x78, 0xc5, 0xd9,
	0x6c, 0xb0, 0xa2, 0xae, 0x28, 0xf9, 0xd8, 0x07, 0x91, 0x1e, 0x34, 0x52, 0xee, 0x88, 0x83, 0x92,
	0xbc, 0xd1, 0x5e, 0xac, 0xf3, 0x8f, 0x02, 0x55, 0x9d, 0x85, 0x02, 0xf9, 0x67, 0x33, 0x9f, 0x3b,
	0xcc, 0x7c, 0x6e, 0x87, 0xf9, 0x8f, 0x70, 0xbc, 0xde, 0xf2, 0xe0, 0x9b, 0x2c, 0xf4, 0x6d, 0xb4,
	0xd5, 0x6a, 0xcc, 0x40, 0x0a, 0x88, 0xf8, 0xdd, 0xec, 0x7e, 0x09, 0xaf, 0xc9, 0xf0, 0x3d, 0xc8,
	0xc1, 0xbe, 0x7e, 0x05, 0x79, 0x2b, 0xe4, 0x01, 0xe3, 0xb2, 0x9f, 0x25, 0x7d, 0x65, 0x45, 0x15,
	0x7b, 0x74, 0x46, 0x85, 0x6c, 0x5d, 0x4e, 0x8f, 0x8d, 0x3d, 0x2a, 0x28, 0xec, 0x55, 0xc1, 0x0f,
	0xa0, 0xcc, 0x98, 0x8d, 0xb2, 0x31, 0xb5, 0xde, 0x37, 0xa9, 0x87, 0xb3, 0xc5, 0xae, 0x36, 0x62,
	0x36, 0xea, 0x72, 0x43, 0xd4, 0xe0, 0x30, 0xc0, 0x5f, 0xd1, 0x31, 0xac, 0xe5, 0x20, 0x2a, 0xc1,
	0xe0, 0x14, 0x03, 0xd9, 0xad, 0xa2, 0xbe, 0x0f, 0x8a, 0x0a, 0x0c, 0x84, 0xc1, 0x85, 0xac, 0x5b,
	0x05, 0xd9, 0xd6, 0x84, 0x27, 0xc2, 0xe5, 0x93, 0x3a, 0x67, 0xa1, 0x2f, 0xd4, 0x72, 0x8c, 0xbf,
	0x78, 0x5e, 0x11, 0x6c, 0xe5, 0x35, 0xc1, 0x76, 0xbe, 0x05, 0x25, 0xba, 0x2f, 0xa9, 0x42, 0x69,
	0x7c, 0xaf, 0x5f, 0xf6, 0x47, 0xc3, 0xdb, 0xeb, 0xfa, 0x17, 0x91, 0x79, 0xd7, 0xbf, 0x1e, 0xde,
	0xf6, 0xef, 0x2f, 0x2f, 0xea, 0x99, 0xce, 0xbf, 0x19, 0x28, 0x8f, 0x65, 0xb9, 0x23, 0x43, 0x58,
	0x6e, 0x24, 0x15, 0xc1, 0x9f, 0x87, 0xf6, 0x1d, 0xc7, 0x09, 0x7d, 0x5e, 0xc9, 0x28, 0xe9, 0xda,
	0x9a, 0x12, 0xd9, 0x9d, 0x29, 0xd1, 0x80, 0x23, 0xea, 0xdb, 0xf8, 0xbc, 0x7a, 0xb9, 0xb1, 0x91,
	0x68, 0x9d, 0xb2, 0xd5, 0xba, 0x1f, 0xa1, 0x6a, 0xb9, 0x06, 0xf5, 0xc7, 0x73, 0xb4, 0xe8, 0x84,
	0x5a, 0x52, 0x4c, 0xe5, 0x5e, 0x43, 0x8b, 0xe7, 0xa3, 0xb6, 0x9e, 0x8f, 0x5a, 0xdf, 0x5f, 0xea,
	0xdb, 0xa1, 0x84, 0x80, 0x12, 0xfa, 0x36, 0x53, 0x9b, 0x92, 0x70, 0xb9, 0x8e, 0xee, 0x4e, 0x39,
	0xdf, 0x68, 0xb8, 0x15, 0x0f, 0x98, 0x84, 0xeb, 0x46, 0x29, 0x42, 0xbd, 0x72, 0xa3, 0x14, 0x6b,
	0xf5, 0x66, 0xef, 0x6f, 0x28, 0xac, 0xc6, 0x16, 0xb9, 0x83, 0xea, 0x58, 0x70, 0x34, 0x66, 0x92,
	0x03, 0x0c, 0xc8, 0xd7, 0xe9, 0x09, 0xba, 0x35, 0xe1, 0x5a, 0xef, 0x53, 0x01, 0x09, 0x12, 0x3f,
	0x65, 0x7a, 0x7f, 0x42, 0x3e, 0x96, 0x0e, 0xf9, 0x6d, 0xf7, 0xec, 0x0f, 0x6f, 0x8b, 0xec, 0xe0,
	0xd1, 0x2e, 0x54, 0x12, 0x5f, 0x04, 0x27, 0x7f, 0xc0, 0x71, 0x9c, 0xe0, 0xc1, 0xb7, 0xd9, 0x3a,
	0x49, 0x5a, 0xc9, 0xe9, 0x6f, 0xe5, 0x50, 0xa6, 0xc1, 0xd9, 0x5f, 0xa7, 0x0e, 0x15, 0x6e, 0x68,
	0x6a, 0x16, 0x9b, 0x75, 0x65, 0xec, 0xf7, 0x94, 0x75, 0xe7, 0xa6, 0xc3, 0xba, 0x3b, 0x3f, 0xde,
	0x4f, 0x73, 0x33, 0x5e, 0x9b, 0x79, 0xd9, 0xb5, 0xb3, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x8b,
	0x73, 0xaa, 0x69, 0x14, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BackendClient is the client API for Backend service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BackendClient interface {
	StreamMatches(ctx context.Context, in *BackendRequest, opts ...grpc.CallOption) (Backend_StreamMatchesClient, error)
}

type backendClient struct {
	cc *grpc.ClientConn
}

func NewBackendClient(cc *grpc.ClientConn) BackendClient {
	return &backendClient{cc}
}

func (c *backendClient) StreamMatches(ctx context.Context, in *BackendRequest, opts ...grpc.CallOption) (Backend_StreamMatchesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Backend_serviceDesc.Streams[0], "/dfuse.search.v1.Backend/StreamMatches", opts...)
	if err != nil {
		return nil, err
	}
	x := &backendStreamMatchesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Backend_StreamMatchesClient interface {
	Recv() (*SearchMatch, error)
	grpc.ClientStream
}

type backendStreamMatchesClient struct {
	grpc.ClientStream
}

func (x *backendStreamMatchesClient) Recv() (*SearchMatch, error) {
	m := new(SearchMatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BackendServer is the server API for Backend service.
type BackendServer interface {
	StreamMatches(*BackendRequest, Backend_StreamMatchesServer) error
}

// UnimplementedBackendServer can be embedded to have forward compatible implementations.
type UnimplementedBackendServer struct {
}

func (*UnimplementedBackendServer) StreamMatches(req *BackendRequest, srv Backend_StreamMatchesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamMatches not implemented")
}

func RegisterBackendServer(s *grpc.Server, srv BackendServer) {
	s.RegisterService(&_Backend_serviceDesc, srv)
}

func _Backend_StreamMatches_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BackendRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BackendServer).StreamMatches(m, &backendStreamMatchesServer{stream})
}

type Backend_StreamMatchesServer interface {
	Send(*SearchMatch) error
	grpc.ServerStream
}

type backendStreamMatchesServer struct {
	grpc.ServerStream
}

func (x *backendStreamMatchesServer) Send(m *SearchMatch) error {
	return x.ServerStream.SendMsg(m)
}

var _Backend_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dfuse.search.v1.Backend",
	HandlerType: (*BackendServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMatches",
			Handler:       _Backend_StreamMatches_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dfuse/search/v1/search.proto",
}

// RouterClient is the client API for Router service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RouterClient interface {
	StreamMatches(ctx context.Context, in *RouterRequest, opts ...grpc.CallOption) (Router_StreamMatchesClient, error)
}

type routerClient struct {
	cc *grpc.ClientConn
}

func NewRouterClient(cc *grpc.ClientConn) RouterClient {
	return &routerClient{cc}
}

func (c *routerClient) StreamMatches(ctx context.Context, in *RouterRequest, opts ...grpc.CallOption) (Router_StreamMatchesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Router_serviceDesc.Streams[0], "/dfuse.search.v1.Router/StreamMatches", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerStreamMatchesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Router_StreamMatchesClient interface {
	Recv() (*SearchMatch, error)
	grpc.ClientStream
}

type routerStreamMatchesClient struct {
	grpc.ClientStream
}

func (x *routerStreamMatchesClient) Recv() (*SearchMatch, error) {
	m := new(SearchMatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RouterServer is the server API for Router service.
type RouterServer interface {
	StreamMatches(*RouterRequest, Router_StreamMatchesServer) error
}

// UnimplementedRouterServer can be embedded to have forward compatible implementations.
type UnimplementedRouterServer struct {
}

func (*UnimplementedRouterServer) StreamMatches(req *RouterRequest, srv Router_StreamMatchesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamMatches not implemented")
}

func RegisterRouterServer(s *grpc.Server, srv RouterServer) {
	s.RegisterService(&_Router_serviceDesc, srv)
}

func _Router_StreamMatches_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouterRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterServer).StreamMatches(m, &routerStreamMatchesServer{stream})
}

type Router_StreamMatchesServer interface {
	Send(*SearchMatch) error
	grpc.ServerStream
}

type routerStreamMatchesServer struct {
	grpc.ServerStream
}

func (x *routerStreamMatchesServer) Send(m *SearchMatch) error {
	return x.ServerStream.SendMsg(m)
}

var _Router_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dfuse.search.v1.Router",
	HandlerType: (*RouterServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMatches",
			Handler:       _Router_StreamMatches_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dfuse/search/v1/search.proto",
}

// ForkResolverClient is the client API for ForkResolver service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ForkResolverClient interface {
	StreamUndoMatches(ctx context.Context, in *ForkResolveRequest, opts ...grpc.CallOption) (ForkResolver_StreamUndoMatchesClient, error)
}

type forkResolverClient struct {
	cc *grpc.ClientConn
}

func NewForkResolverClient(cc *grpc.ClientConn) ForkResolverClient {
	return &forkResolverClient{cc}
}

func (c *forkResolverClient) StreamUndoMatches(ctx context.Context, in *ForkResolveRequest, opts ...grpc.CallOption) (ForkResolver_StreamUndoMatchesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ForkResolver_serviceDesc.Streams[0], "/dfuse.search.v1.ForkResolver/StreamUndoMatches", opts...)
	if err != nil {
		return nil, err
	}
	x := &forkResolverStreamUndoMatchesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ForkResolver_StreamUndoMatchesClient interface {
	Recv() (*SearchMatch, error)
	grpc.ClientStream
}

type forkResolverStreamUndoMatchesClient struct {
	grpc.ClientStream
}

func (x *forkResolverStreamUndoMatchesClient) Recv() (*SearchMatch, error) {
	m := new(SearchMatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ForkResolverServer is the server API for ForkResolver service.
type ForkResolverServer interface {
	StreamUndoMatches(*ForkResolveRequest, ForkResolver_StreamUndoMatchesServer) error
}

// UnimplementedForkResolverServer can be embedded to have forward compatible implementations.
type UnimplementedForkResolverServer struct {
}

func (*UnimplementedForkResolverServer) StreamUndoMatches(req *ForkResolveRequest, srv ForkResolver_StreamUndoMatchesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamUndoMatches not implemented")
}

func RegisterForkResolverServer(s *grpc.Server, srv ForkResolverServer) {
	s.RegisterService(&_ForkResolver_serviceDesc, srv)
}

func _ForkResolver_StreamUndoMatches_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ForkResolveRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ForkResolverServer).StreamUndoMatches(m, &forkResolverStreamUndoMatchesServer{stream})
}

type ForkResolver_StreamUndoMatchesServer interface {
	Send(*SearchMatch) error
	grpc.ServerStream
}

type forkResolverStreamUndoMatchesServer struct {
	grpc.ServerStream
}

func (x *forkResolverStreamUndoMatchesServer) Send(m *SearchMatch) error {
	return x.ServerStream.SendMsg(m)
}

var _ForkResolver_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dfuse.search.v1.ForkResolver",
	HandlerType: (*ForkResolverServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamUndoMatches",
			Handler:       _ForkResolver_StreamUndoMatches_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "dfuse/search/v1/search.proto",
}
